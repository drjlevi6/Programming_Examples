%!PS% Sierp1.ps: Program to produce Sierpinski curves C0, C1, C2…% Each curve C(i) is built up from preceding C(i-1), but% only final curve C(n) is drawn.%% Currently,  desired level n has to be entered by user% altering the program.%% J Levi 4/2000% Procedures and variables:/x0 80 def					% bottom-left corner of box/y0 270 def				%		where curve will be drawn%*********************************************************/leveltodraw 4 def		% USER MUST SET: 0, 1, 2, 3...%*********************************************************/scalefac 64 def/boxsize {scalefac 8 mul} def/segxysize scalefac def	% Initial size of x, y-component of a move during drawing.							% (Size changed for all curves other than C0.)/themoves					% Array of unscaled “moves” (rmoveto increments) for curve C0	[		[1 1][0 2][-1 1][1 1]		[1 -1][2 0][1 1][1 -1]		[-1 -1][0 -2][1 -1][-1 -1]		[-1 1][-2 0][-1 -1][-1 1]	] def/drawbox {	% ---------draw box enclosing curve----------------	gsave	0.5 setgray	0 0 moveto	boxsize 0 rlineto	0 boxsize rlineto	boxsize neg 0 rlineto	closepath stroke	grestore} def/drawgrid	{	% ---------draw  8x8 grid pattern------------------	gsave	0.5 setgray	1 1 7 {		dup scalefac mul 0 moveto		 0 boxsize rlineto		 scalefac mul 0 exch moveto		 boxsize 0 rlineto	} for	stroke	grestore} def/drawsegs {	% ---------draw the curve itself-------------------	gsave	0.5 setlinewidth	segxysize segxysize 2 mul moveto	themoves aload		% place moveto coordinate pairs on stack	length -1 2 {			% set up for-loop: omit last coord pair		-1 roll			% temp value rolls coord pair at bottom of stack to top		aload pop		segxysize mul exch		segxysize mul exch		rlineto	} for	pop						% discard last coord pair (use closepath instead)	closepath stroke 	grestore} def/adjustxysize {	%--------scale down segment length for non-C0 curves	leveltodraw {		/segxysize		segxysize 2 div def	} repeat} def/recalcsegments {	%--------calc move segments for next higher-level curve	leveltodraw {		themoves aload			% get moves for bottom left quadrent, 1st half		length 0.5 mul 1 add		% save only bottom half of coords on stack		mark exch		cvi 1 roll		cleartomark		pop							% replace top move (which turns a corner)...		[0 2]						%		with a vertical move		themoves aload			% get moves for top left quadrent		length dup		-0.75 mul cvi roll		pop [2 0]		themoves aload			% moves for top right quadrent		pop pop [0 -2]		themoves aload			% moves for bottom right quadrant		length dup		-4 div cvi roll		pop [-2 0]% ***This much works***		themoves aload			% moves for bottom left quadrant, last half		length mark		exch dup		1 add exch		-2 div cvi roll		cleartomark		count array astore		% when done, store the new moves in an array...		/themoves exch def		% ...which replaces the old array	} repeat} def		% ----------------main program--------------------------x0 y0 translatedrawboxdrawgridleveltodraw 0 gt {	adjustxysize	recalcsegments} if									% recompute segs for nonzero levelsdrawsegsshowpage