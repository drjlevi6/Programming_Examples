%!PS% Sierp2.ps: Program to produce Sierpinski curves C0, C1, C2…% Each curve C(i) is built up from preceding C(i-1), but% only final curve C(n) is drawn.%% Sierp2 attempts to improve upon Sierp1 in efficiency by loading the “moveto”% segments in reverse order. Access will then be simpler in drawing (will only% have to pop the segments rather than roll the entire stack.)%% Currently,  desired level n has to be entered by user% altering the program.%% J Levi 4/2000% Procedures and variables:/x0 54 def					% bottom-left corner of box/y0 250 def				%		where curve will be drawn%*********************************************************/leveltodraw 5 def		% USER MUST SET: 0, 1, 2, 3...% Highest level that either MacGS or my LaserPrinter can handle is 5.%*********************************************************/scalefac 64 def/boxsize {scalefac 8 mul} def/segxysize scalefac def	% Initial size of x, y-component of a move during drawing.							% (Size changed for all curves other than C0.)/themoves					% Array of unscaled “moves” (rmoveto increments) for curve C0,							%arranged in reverse order	[		[-1 1][-1 -1][-2 0][-1 1]		[-1 -1][1 -1][0 -2][-1 -1]		[1 -1][1 1][2 0][1 -1]		[1 1][-1 1][0 2][1 1]	] def/drawbox {	% ---------draw box enclosing curve----------------	gsave	0 setgray	1 setlinewidth	0 0 moveto	boxsize 0 rlineto	0 boxsize rlineto	boxsize neg 0 rlineto	closepath stroke	grestore} def/drawgrid	{	% ---------draw  8x8 grid pattern------------------	gsave	0.5 setgray	0.5 setlinewidth	1 1 7 {		dup scalefac mul 0 moveto		 0 boxsize rlineto		 scalefac mul 0 exch moveto		 boxsize 0 rlineto	} for	stroke	grestore} def/drawlegend {	/Helvetica findfont 12 scalefont setfont	256 -13 moveto	(C) show	leveltodraw 1 string cvs show} def/drawsegs {	% ---------draw the curve itself-------------------	gsave	0.25 setlinewidth	segxysize segxysize 2 mul moveto	themoves aload		% place moveto coordinate pairs on stack	length 1 sub 		{			% set up for-loop: omit last coord pair		aload pop		segxysize mul exch		segxysize mul exch		rlineto	}repeat	pop						% discard last coord pair (use closepath instead)	closepath stroke 	grestore} def/adjustxysize {	%--------scale down segment length for non-C0 curves	leveltodraw {		/segxysize		segxysize 2 div def	} repeat} def/recalcsegments {	%--------calc move segments for next higher-level curve	leveltodraw {		% Push moves for bot left quadrant (1st half)		themoves aload length		% e.g. [m16]...[m1] 16		2 div cvi {pop} repeat [-2 0]	% [m16]...[m9][-2 0]		% Push moves for bottom right quadrant		themoves aload length		% <stkbot>[m16]...[m1] 16		dup 4 div 1 sub cvi roll	% <stkbot>[m3]...[m1][m16]...[m4]		pop [0 -2]				% <stkbot>[m3]...[m1][m16]...[m4][0 -2]		% Push moves for top right quadrant		themoves aload length		% <stkbot>[m16]...[m1] 16		-1 roll pop [2 0]			% <stkbot>[m15]...[m1][2 0]		% Push moves for top left quadrant		themoves aload length		% <stkbot>[m16]...[m1] 16		dup -4 div 1 sub cvi roll	% <stkbot>[m11]...[m1][16]...[m12]		pop [0 2]					% <stkbot>[m11]...[m1][16]...[m13][0 2]		% Push moves for bot left quadrant (1st half)		themoves aload length		% <stkbot>[m16]...[m1] 16		dup /numsegs exch def		dup 2 div 1 sub cvi roll	% <stkbot>[m7]...[m1][m16]...[m9] [m8]		numsegs 2 div cvi 1 add	% <stkbot>[m7]...[m1][m16]...[m9] [m8] 9		{pop} repeat				% <stkbot>[m7]...[m1]		count array astore /themoves exch def	} repeat} def		% ----------------main program--------------------------x0 y0 translatedrawboxdrawgridleveltodraw 0 gt {	adjustxysize	recalcsegments} if									% recompute segs for nonzero levelsdrawsegsdrawlegendshowpage